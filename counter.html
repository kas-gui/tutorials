<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Counter - KAS tutorials</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="hello.html"><strong aria-hidden="true">2.</strong> Hello</a></li><li class="chapter-item expanded "><a href="counter.html" class="active"><strong aria-hidden="true">3.</strong> Counter</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">KAS tutorials</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#counter" id="counter">Counter</a></h1>
<p><img src="screenshots/counter.png" alt="Counter" /></p>
<p>This tutorial follows on from <a href="hello.html">hello</a>, turning the example into a counter.</p>
<h2><a class="header" href="#layout" id="layout">Layout</a></h2>
<p>To make a counter, we need two widgets: a button and a label. Lets solve the
layout part first, using <code>make_widget</code> (although this isn't the only way to do
layout).</p>
<pre><pre class="playground"><code class="language-rust">use kas::event::VoidMsg;
use kas::macros::make_widget;
use kas::widget::{Label, TextButton, Window};

fn main() -&gt; Result&lt;(), kas_wgpu::Error&gt; {
    env_logger::init();

    let content = make_widget! {
        #[layout(column)]
        #[handler(msg = VoidMsg)]
        struct {
            #[widget(halign = centre)] display = Label::new(&quot;0&quot;.to_string()),
            #[widget] _ = TextButton::new(&quot;&amp;count&quot;),
            counter: u32 = 0,
        }
    };
    let window = Window::new(&quot;Counter&quot;, content);

    let theme = kas_theme::ShadedTheme::new();
    kas_wgpu::Toolkit::new(theme)?.with(window)?.run()
}
</code></pre></pre>
<h3><a class="header" href="#make_widget" id="make_widget">make_widget</a></h3>
<p><code>make_widget</code> is a macro, and macros are allowed to invent syntax. The contents
of <code>make_widget!{..}</code> look <em>roughly</em> like normal Rust code, but with a few
oddities.</p>
<p>If you are looking for the API reference for <code>make_widget</code>, there isn't one.
There simply isn't a standard way to write macro documentation.
There is a reference manual, <a href="https://docs.rs/kas/latest/kas/macros/index.html"><code>kas::macros</code></a>, but for now it's probably better
to continue reading this tutorial.</p>
<p>So what does <code>make_widget</code> actually <em>do</em>? It's quite simple actually: it creates
an anonymous/unnamed struct (which Rust does not have native syntax for),
adds <code>#[derive(Debug, kas::macros::Widget)]</code> to it, and creates two hidden
fields (<code>core</code> and <code>layout_data</code>). (This is a lie. Making
anonymous structs work nicely via a macro is not simple, and there are several
features applicable only to widgets. But it gives you a rough idea.)</p>
<p>Most of what follows is <em>actually</em> about the <code>derive(Widget)</code> macro, which
you'll see more of later.</p>
<h4><a class="header" href="#widget-attributes" id="widget-attributes">Widget attributes</a></h4>
<p>From the code above:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[layout(column)]
#[handler(msg = VoidMsg)]
struct { .. }
<span class="boring">}
</span></code></pre></pre>
<p>The widget we are making is a &quot;parent&quot; widget, with <code>column</code> layout. (A few
other layouts are available, such as <code>single</code>, <code>row</code>, <code>grid</code>, <code>left</code>.)</p>
<p>The widget produces a message of type <a href="https://docs.rs/kas/latest/kas/event/enum.VoidMsg.html"><code>VoidMsg</code></a>. This is a &quot;void type&quot; (i.e.
<code>enum VoidMsg {}</code>) and as such cannot be constructed: in other words, the
widget does not produce any messages.</p>
<p>Aside: <code>VoidMsg</code> could and <em>should</em> be the default allowing the <code>handler</code>
attribute to be omitted, but using the wrong type currently results in very poor
error messages, so for now it's better if the macro does not make any
assumptions about the message type.</p>
<h4><a class="header" href="#the-widget-struct" id="the-widget-struct">The widget struct</a></h4>
<p>As said, <code>make_widget</code> constructs an anonymous struct. Structs have fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct {
    #[widget(halign = centre)] display = Label::new(&quot;0&quot;.to_string()),
    #[widget] _ = TextButton::new(&quot;&amp;count&quot;),
    counter: u32 = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, you'll notice a few strange things here:</p>
<ul>
<li>The struct has no name, of course.</li>
<li>Fields are assigned <em>values</em>. Since the struct is unnamed, it <em>must</em> be
constructed immediately, hence <em>values</em> are essential.</li>
<li>Field <em>types</em> are often omitted, since they can often be inferred. (Warning:
inferred types use type parameters internally, and can produce
strange error messages).</li>
<li>Fields don't always have <em>names</em>. With widgets it's quite common that you
never need to refer to a field after constructing it, hence you can just
use <code>_</code>.</li>
<li>The first two fields are a <code>#[widget]</code> ...</li>
</ul>
<p>A widget must be <em>configured</em> when the GUI is constructed, must have size
constraints evaluated and be assigned a rectangle, and (if interactive) must
handle events (and more). The <code>#[widget]</code> attribute sets this stuff up for each
child widget.</p>
<p>This attribute allows some configuration, here <code>halign = centre</code> (set horizontal
alignment to centre). This is all covered in the <a href="https://docs.rs/kas/latest/kas/macros/index.html"><code>kas::macros</code></a> manual, but
for now lets move on.</p>
<h2><a class="header" href="#events-and-messages" id="events-and-messages">Events and messages</a></h2>
<p>Now, lets make the button work, using <em>messages</em>.</p>
<pre><pre class="playground"><code class="language-rust">use kas::class::HasString;
use kas::event::{Manager, Response, VoidMsg};
use kas::macros::make_widget;
use kas::widget::{Label, TextButton, Window};

fn main() -&gt; Result&lt;(), kas_wgpu::Error&gt; {
    env_logger::init();

    let content = make_widget! {
        #[layout(column)]
        #[handler(msg = VoidMsg)]
        struct {
            #[widget(halign = centre)] display: impl HasString =
                Label::new(&quot;0&quot;.to_string()),
            #[widget(handler = count)] _ = TextButton::new_msg(&quot;&amp;count&quot;, ()),
            counter: u32 = 0,
        }
        impl {
            fn count(&amp;mut self, mgr: &amp;mut Manager, _: ()) -&gt; Response&lt;VoidMsg&gt; {
                self.counter += 1;
                *mgr |= self.display.set_string(self.counter.to_string());
                Response::None
            }
        }
    };
    let window = Window::new(&quot;Counter&quot;, content);

    let theme = kas_theme::ShadedTheme::new();
    kas_wgpu::Toolkit::new(theme)?.with(window)?.run()
}
</code></pre></pre>
<pre><code class="language-sh">cargo run --example counter
</code></pre>
<h3><a class="header" href="#messages" id="messages">Messages</a></h3>
<p>First off, our button's constructor is now: <code>TextButton::new_msg(&quot;&amp;count&quot;, ())</code>.
Lets look at the <a href="https://docs.rs/kas/latest/kas/widget/struct.TextButton.html"><code>TextButton</code></a> API again.</p>
<p><code>new_msg</code> is just a convenience method. We could have used
<code>TextButton::new_on(&quot;&amp;count&quot;, |_| Some(()))</code> or even
<code>TextButton::new(&quot;&amp;count&quot;).on_push(|_| Some(()))</code>. But why?</p>
<p>Traditional GUI toolkits like Qt and GTK allow widgets communicate by passing
pointers/references about. Several modern toolkits, inspired by
<a href="https://guide.elm-lang.org/architecture/">the Elm architecture</a>, separate View
(widgets) from Model (state/data) entirely. KAS does neither of these things:
state can be stored in widgets (like Qt), and type-safe <em>messages</em> are used to
communicate between widgets.</p>
<p>Messages are very simple: an interactive widget generates a message when
something happens (like a button being clicked), puts it in a <a href="https://docs.rs/kas/latest/kas/event/enum.Response.html"><code>Response</code></a>,
then the message gets sent up to the parent widget, where it either gets handled
or sent up again (to the parent's parent).</p>
<p>Note that a window cannot send messages anywhere, so the top widget's message
type must be <a href="https://docs.rs/kas/latest/kas/event/enum.VoidMsg.html"><code>VoidMsg</code></a>.</p>
<h3><a class="header" href="#a-handler" id="a-handler">A handler</a></h3>
<p>Our &quot;count&quot; button doesn't need to send a complicated message, so we just use
<code>()</code>. This is the second parameter of the constructor:
<code>TextButton::new_msg(&quot;&amp;count&quot;, ())</code>.</p>
<p>To handle this, we put a method on our widget:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl {
    fn count(&amp;mut self, mgr: &amp;mut Manager, _: ()) -&gt; Response&lt;VoidMsg&gt; {
        self.counter += 1;
        *mgr |= self.display.set_string(self.counter.to_string());
        Response::None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that, as with <code>struct</code>, there is no name on the <code>impl</code>. Beyond that, this
is just a normal method:</p>
<ul>
<li>handlers must have parameters <code>&amp;mut self</code>, <code>mgr</code>, and <code>msg: M</code> (where <code>M</code>
is the type of the message being handled)</li>
<li>handlers return <code>Response&lt;N&gt;</code> where <code>N</code> is the message type send to the
parent (in this case <code>VoidMsg</code> since we're done handling this event)</li>
</ul>
<p>In this particular case, we ignore the message (since <code>()</code> is not interesting),
increment our <code>counter</code> field, and update the <code>display</code>.</p>
<p>Note that <code>self.display.set_string(..)</code> returns a <a href="https://docs.rs/kas/latest/kas/struct.TkAction.html"><code>TkAction</code></a>. This is a type
indicating to the GUI which &quot;update&quot; actions are needed. Internally it is a
<a href="https://docs.rs/bitflags/"><code>bitflags</code></a> struct, so two actions can be combined with <code>a | b</code> and an action
can be forwarded to the manager with <code>*mgr |= action</code>.</p>
<p>Note also that there is a little trust in the GUI developer here: if the action
is ignored, an update might not happen. This is never catastrophic, and
sometimes completely harmless (e.g. in this case a re-draw will be requested by
the button being pressed anyway). Note also that <a href="https://docs.rs/kas/latest/kas/struct.TkAction.html"><code>TkAction</code></a> has the
<code>#[must_use]</code> attribute so the compiler won't let you forget it.</p>
<h3><a class="header" href="#attributes-and-bounds" id="attributes-and-bounds">Attributes and bounds</a></h3>
<p>In order to bind our <code>count</code> method to the <a href="https://docs.rs/kas/latest/kas/widget/struct.TextButton.html"><code>TextButton</code></a>, we use the <code>widget</code>
attribute again: <code>#[widget(handler = count)]</code>.</p>
<p>Finally, to make it possible to use the <code>self.display.set_string</code> method in our
<code>count</code> method, we need to <em>either</em> give <code>display</code> a concrete type
(<code>Label&lt;String&gt;</code>) <em>or</em> bound it with the <a href="https://docs.rs/kas/latest/kas/class/trait.HasString.html"><code>HasString</code></a> trait.
We do the latter with the <code>impl Trait</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[widget(halign = centre)] display: impl HasString = Label::new(&quot;0&quot;.to_string()),
#[widget(handler = count)] _ = TextButton::new_msg(&quot;&amp;count&quot;, ()),
<span class="boring">}
</span></code></pre></pre>
<p>Aside: it should (in my opinion) be possible to call methods and access fields
on fields with inferred types without a trait bound, but for now it's not
(a language limitation). This is KAS#15.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="hello.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="hello.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
